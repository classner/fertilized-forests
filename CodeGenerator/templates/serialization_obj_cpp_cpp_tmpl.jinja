## Author: Christoph Lassner.
{% include "cpp_disclaimer.jinja" %}
{% import 'cpptools.jinja' as cpptools %}

#if defined SERIALIZATION_ENABLED
#include "../global.h"

#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/serialization/version.hpp>

@ if cls.Package != 'rootdir'
#include "../{{cls.Package}}/{{cls.ClassName|lower}}.h"
@ else
#include "../{{cls.ClassName|lower}}.h"
@ endif
#include "./_serialization_definition.h"

namespace fertilized {
  template <class Archive>
  void __serialization_register_{{tplid}}(Archive &ar) {
@ if not cls.IsAbstract
@ if not insttypes is none
    ar.template register_type<{{cls.ClassName}}<{{cpptools.render_types(insttypes.Types)}}	  >>();
@ else
    ar.template register_type<{{cls.ClassName}}>();
@ endif
@ endif
  };
  TemplateFuncExport DllExport void __serialization_register_{{tplid}}(boost::archive::text_iarchive &ar);
  TemplateFuncExport DllExport void __serialization_register_{{tplid}}(boost::archive::text_oarchive &ar);

@ if not insttypes is none
    TemplateFuncExport DllExport std::string serialize(const {{cls.ClassName}}<{{cpptools.render_types(insttypes.Types)}}	  > *, const bool &);
@ else
    TemplateFuncExport DllExport std::string serialize(const {{cls.ClassName}}*, const bool &);
@ endif

@ if not insttypes is none
    TemplateFuncExport DllExport {{cls.ClassName}}<{{cpptools.render_types(insttypes.Types)}}	  >* deserialize(std::stringstream &);
@ else
    TemplateFuncExport DllExport {{cls.ClassName}}* deserialize(std::stringstream &);
@ endif

@ if not insttypes is none
    TemplateFuncExport DllExport void deserialize(std::stringstream &, {{cls.ClassName}}<{{cpptools.render_types(insttypes.Types)}}	  >*);
@ else
    TemplateFuncExport DllExport void deserialize(std::stringstream &, {{cls.ClassName}}*);
@ endif
}  // namespace fertilized

// For types, etc.
using namespace fertilized;
namespace boost {
namespace serialization {

@ if not insttypes is none
template <>
struct version<{{cls.ClassName}}<{{cpptools.render_types(insttypes.Types)}}	  >> {
    typedef mpl::int_<FERTILIZED_VERSION_COUNT> type;
    typedef mpl::integral_c_tag tag;
    BOOST_STATIC_CONSTANT(int, value = version::type::value);
    BOOST_MPL_ASSERT((
        boost::mpl::less<
            boost::mpl::int_<FERTILIZED_VERSION_COUNT>,
            boost::mpl::int_<256>
        >
    ));
};
@ else
template<>
struct version<{{cls.ClassName}} > {
    typedef mpl::int_<FERTILIZED_VERSION_COUNT> type;
    typedef mpl::integral_c_tag tag;
    BOOST_STATIC_CONSTANT(int, value = version::type::value);
    BOOST_MPL_ASSERT((
        boost::mpl::less<
            boost::mpl::int_<FERTILIZED_VERSION_COUNT>,
            boost::mpl::int_<256>
        >
    ));
};
@ endif
}
}

#endif  // SERIALIZATION_ENABLED
