## Author: Christoph Lassner.
{% include 'cpp_disclaimer.jinja' %}
{% import 'cpptools.jinja' as cpptools %}

#ifndef MATFERTILIZED_MATLAB_HEADERS_{{ package|upper }}_H_
#define MATFERTILIZED_MATLAB_HEADERS_{{ package|upper }}_H_

#include <mex.h>

#include "./global.h"

#ifdef __cplusplus
extern "C"
{
#endif
@ for class in classes
@ 	for m in class.Methods
@		if 'Matlab' in m.AvailableIn
            ## Create methods of form: __declspec(dllexport) ReturnType MethodName(Arguments);
@ 			if class.ClassType.TemplateParams is none or class.ClassType.TemplateParams | length == 0
        ## generate a no argument method!			
    DllExport {{ m.ReturnType.getCType(is_return_type=True) }} {{m.prefixForMatlab(m.FunctionPrefix)}}{{ m.NameFormat|format(class.ClassName, "") }} ({%if not m.IsConstructor %}void *__instance{%if m.Arguments|length > 0%},{%endif%}{%endif%}{{ cpptools.render_arguments(m, render_defaults=False, as_c_types=True) }});
@			else
        ## generate a method with template arguments (for each of the supported types)
@			for t in class.SupportedTypes	
@				set suffix = "_" + t.TypesString		

    DllExport {{ m.ReturnType.getCType() }} {{m.prefixForMatlab(m.FunctionPrefix)}}{{ m.NameFormat|format(class.ClassName, suffix) }} ({%if not m.IsConstructor %}void *__instance{%if m.Arguments|length > 0%},{%endif%}{%endif%}{{ cpptools.render_arguments(m, render_defaults=False, as_c_types=True, vec_subst=True, template_params=class.ClassType.TemplateParams, instantiation_types=t) }});
@			endfor		
@			endif
@		endif
@	endfor
@   if class.ClassType.TemplateParams is none or class.ClassType.TemplateParams | length == 0
    DllExport void delete_{{class.ClassName}}(void *ptr);
@   else
@     for instantiation_types in class.SupportedTypes
    DllExport void delete_{{class.ClassName}}_{{instantiation_types.TypesString}}(void *ptr);
@     endfor
@   endif
@ endfor

#ifdef __cplusplus
}
#endif 

#endif //#ifndef MATFERTILIZED_MATLAB_HEADERS_{{ package|upper }}_H_